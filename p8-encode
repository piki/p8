#!/usr/bin/env ruby
#
# Usage:
#   ./p8-encode <frameskip> <width> <diffenc> <files...> > output.lua
#     <frameskip> - encode every Nth frame, for 1/N fps.
#     <width>     - scale the frame to NxN before encoding.
#     <diffenc>   - true|false to encode delta frames instead of keyframes
#                   true produces smaller files for <frameskip> <= than 4 or so.
#                   true may also currently be broken
# Example:
#   ./p8-encode 8 34 false ~/img/output*.png > bad-apple.lua

require 'rubygems'
require 'bundler/setup'
require 'RMagick'
include Magick

# set CHEATS to true to drop some individual pixels to produce smaller files
# It reduces file size by a about 1/3, but looks pretty bad.
CHEATS = false
MAX_AGE = 4  # maximum number of frames a pixel can be left wrong
@age = Hash.new(0)

def main
	fail unless ARGV.size >= 4
	frameskip = ARGV.shift.to_i
	res = ARGV.shift.to_i
	@prev = [0] * (res * res)
	@cheats = 0
	differential_encoding = %w[true yes on 1].include?(ARGV.shift.downcase)
	files = ARGV

	print header.chomp

	files = (0...files.size).select{|n| n%frameskip == 0}.map{|n| files[n]}
	files.each do |fn|
		canvas = ImageList.new(fn).first
		square = [canvas.columns, canvas.rows].min
		canvas.crop!(CenterGravity, square, square)
		canvas.scale!(res, res)
		canvas = canvas.threshold(QuantumRange/2)
		bw = []
		canvas.each_pixel do |pixel, c, r|
			bw << ((pixel.intensity >= QuantumRange/2) ? 1 : 0)
		end

		$stderr.puts "\033[H\033[2J#{fn}"
		(0...res).each do |y|
			$stderr.puts (0...res).map { |x|
				idx = y*res+x
				idx = (@prev[idx]<<1)+bw[idx]
#				" o. "[idx]
				"X X "[idx]
			}.join
		end
		if differential_encoding
			put_frame_differential(bw, res)
		else
			put_frame(bw, res)
		end
		$stderr.puts @cheats if differential_encoding && CHEATS
	end
	print footer(frameskip, res, differential_encoding).gsub("\t", "").gsub("\n\n", "\n")
end

def header
	<<EOF
pico-8 cartridge // http://www.pico-8.com
version 34
__lua__
f={"
EOF
end

CHARMAP=" 0123456789abcdefghijklmnopqrstuvwxyz!#%(){}[]<>+=/*:;.,~_-@$^|&?`'"

def put_frame(bw, res)
	fail unless bw.size == res*res
	if bw == @prev
		ret = " "
	else
		ret = ""
		col = 0
		left = 0
		while bw[left] == @prev[left]
			left += 1
		end
		left -= (left%4)
		ret << enc(left/4)
		while left < bw.size
			break if bw[left..-1] == @prev[left..-1]
			right = left
			while right < bw.size && bw[right] == col
				right += 1
			end
			ret << enc(right-left)
			col ^= 1
			left = right
		end
	end
	print "#{ret}#{CHARMAP[-1]}"
	maybe_flush(ret.size+1)
	@prev = bw
end

def enc(n)
	if n >= CHARMAP.size-2
		lo = n % (CHARMAP.size-2)
		hi = n / (CHARMAP.size-2)
		CHARMAP[-2] + CHARMAP[hi] + CHARMAP[lo]
	else
		CHARMAP[n]
	end
end

def put_frame_differential(bw, res)
	fail unless bw.size == res*res
	if CHEATS
		mod = bw.clone
		(2...bw.size-2).each do |i|
			if @age[i] < MAX_AGE && bw[i-2..i+2] == [@prev[i-2], @prev[i-1], 1-@prev[i], @prev[i+1], @prev[i+2]]
				mod[i] = 1-bw[i]
				@cheats += 1
				@age[i] += 1
			elsif @age[i] < MAX_AGE && bw[i-2..i+2] == [1-@prev[i-2], 1-@prev[i-1], @prev[i], 1-@prev[i+1], 1-@prev[i+2]]
				mod[i] = 1-bw[i]
				@cheats += 1
				@age[i] += 1
			else
				mod[i] = bw[i]
				@age[i] = 0
			end
		end
		bw = mod
	end

	delta = (0...bw.size).map{|i| @prev[i] ^ bw[i]}
	if bw == @prev
		ret = " "
	else
		ret = ""
		flip = 1
		left = 0
		while bw[left] == @prev[left]
			left += 1
		end
		left -= (left%4)
		ret << enc(left/4)
		while left < bw.size
			break if delta[left..-1].sum == 0
			right = left
			while right < bw.size && delta[right] == flip
				right += 1
			end
			ret << enc(right-left)
			flip ^= 1
			left = right
		end
	end
	print "#{ret}#{CHARMAP[-1]}"
	maybe_flush(ret.size+1)
	@prev = bw
end

@slen = 0
def maybe_flush(len)
	@slen += len
	if @slen > 32000
		print '","'
		@slen = 0
	end
end

def footer(frameskip, res, differential_encoding)
	sqsize = 128/res
	<<EOF
"}

m={}

for i=1,#{CHARMAP.size} do
	m[sub("#{CHARMAP}",i,_)] = i-1
end

s=#f+1
function z()
	if o>#f[s] then
		s+=1
		o=1
	end
	r=m[sub(f[s],o,_)]
	o+=1
	if (r==#{CHARMAP.size-1}) then return -1 end
	if r==#{CHARMAP.size-2} then
		o+=2
		return m[sub(f[s],o-1,_)]+#{CHARMAP.size-2}*m[sub(f[s],o-2,_)]
	end
	return r
end

function _draw()
	if s>#f or (s==#f and o>#f[s]) then
		n=0
		s=1
		o=1
		cls()
		music()
	end
	n+=1
	if (n%#{frameskip}!=0) then return end
	#{differential_encoding ? "c=true" : "c=0"}
	p=4*z()
	k=z()
	while k!=-1 do
		for j=1,k do
			x=(p%#{res})*#{sqsize}
			y=flr(p/#{res})*#{sqsize}
			#{differential_encoding ? "if (c) then
				c=bxor(7,pget(x,y))
				rectfill(x,y,x+#{sqsize-1},y+#{sqsize-1},c)
			end" : "rectfill(x,y,x+#{sqsize-1},y+#{sqsize-1},c)"}
			p+=1
		end
		#{differential_encoding ? "c=not c" : "c=(c+7)%14"}
		k=z()
	end
end
EOF
# c = color, or change flag
# f = frame data
# i, j = iterators
# k = run-length encoding count
# m = map from character value to 6-bit number
# n = counter from 1..number of _draw() calls (30*duration)
# s = current string within f
# o = offset within f[s]
# p = pointer to output square
end

main
