#!/usr/bin/env ruby
#
# Usage:
#   ./p8-encode <frameskip> <width> <diffenc> <files...> > output.lua
#     <frameskip> - encode every Nth frame, for 1/N fps.
#     <width>     - scale the frame to NxN before encoding.
#     <diffenc>   - true|false to encode delta frames instead of keyframes
#                   true produces smaller files for <frameskip> <= than 4 or so.
#                   true may also currently be broken
# Example:
#   ./p8-encode 8 34 false ~/img/output*.png > bad-apple.lua

require 'rubygems'
require 'bundler/setup'
require 'RMagick'
include Magick

# set CHEATS to true to drop some individual pixels to produce smaller files
# It reduces file size by a about 1/3, but looks pretty bad.
CHEATS = false
MAX_AGE = 4  # maximum number of frames a pixel can be left wrong
@age = Hash.new(0)

def main
	fail unless ARGV.size >= 4
	frameskip = ARGV.shift.to_i
	res = ARGV.shift.to_i
	@prev = [0] * (res * res)
	@cheats = 0
	differential_encoding = %w[true yes on 1].include?(ARGV.shift.downcase)
	files = ARGV

	print header.chomp

	files = (0...files.size).select{|n| n%frameskip == 0}.map{|n| files[n]}
	files.each do |fn|
		canvas = ImageList.new(fn).first
		square = [canvas.columns, canvas.rows].min
		canvas.crop!(CenterGravity, square, square)
		canvas.scale!(res, res)
		canvas = canvas.threshold(QuantumRange/2)
		bw = []
		canvas.each_pixel do |pixel, c, r|
			bw << ((pixel.intensity >= QuantumRange/2) ? 1 : 0)
		end

		$stderr.puts "\033[H\033[2J#{fn}"
		(0...res).each do |y|
			$stderr.puts (0...res).map { |x|
				idx = y*res+x
				idx = (@prev[idx]<<1)+bw[idx]
#				" o. "[idx]
				"X X "[idx]
			}.join
		end
		if differential_encoding
			put_frame_differential(bw, res)
		else
			put_frame(bw, res)
		end
		$stderr.puts @cheats if differential_encoding && CHEATS
	end
	print footer(frameskip, res, differential_encoding).gsub("\t", "").gsub("\n\n", "\n")
end

def header
	<<EOF
pico-8 cartridge // http://www.pico-8.com
version 34
__lua__
f={
EOF
end

CHARMAP=" 0123456789abcdefghijklmnopqrstuvwxyz!#%(){}[]<>+=/*:;.,~_-@$^|`'"

def put_frame(bw, res)
	fail unless bw.size == res*res
	if bw == @prev
		ret = " "
	else
		ret = ""
		col = 0
		left = 0
		while left/4 < CHARMAP.size-1 && bw[left] == @prev[left]
			left += 1
		end
		left -= (left%4)
		ret << CHARMAP[left/4]
		while left < bw.size
			break if bw[left..-1] == @prev[left..-1]
			right = left
			while right < bw.size && bw[right] == col && right-left < CHARMAP.size-1
				right += 1
			end
			ret << enc(right-left)
			col ^= 1
			left = right
		end
	end
	print %Q{"#{ret}",}
	@prev = bw
end

def enc(n)
	fail if n >= CHARMAP.size
	return CHARMAP[n]
	if n >= CHARMAP.size-1
		lo = n % (CHARMAP.size-1)
		hi = n / (CHARMAP.size-1)
		CHARMAP[-1] + CHARMAP[lo] + CHARMAP[hi]
	else
		CHARMAP[n]
	end
end

def put_frame_differential(bw, res)
	fail unless bw.size == res*res
	if CHEATS
		mod = bw.clone
		(2...bw.size-2).each do |i|
			if @age[i] < MAX_AGE && bw[i-2..i+2] == [@prev[i-2], @prev[i-1], 1-@prev[i], @prev[i+1], @prev[i+2]]
				mod[i] = 1-bw[i]
				@cheats += 1
				@age[i] += 1
			elsif @age[i] < MAX_AGE && bw[i-2..i+2] == [1-@prev[i-2], 1-@prev[i-1], @prev[i], 1-@prev[i+1], 1-@prev[i+2]]
				mod[i] = 1-bw[i]
				@cheats += 1
				@age[i] += 1
			else
				mod[i] = bw[i]
				@age[i] = 0
			end
		end
		bw = mod
	end

	delta = (0...bw.size).map{|i| @prev[i] ^ bw[i]}
	if bw == @prev
		ret = " "
	else
		ret = ""
		flip = 1
		left = 0
		while left/4 < CHARMAP.size-1 && bw[left] == @prev[left]
			left += 1
		end
		left -= (left%4)
		ret << CHARMAP[left/4]
		while left < bw.size
			break if delta[left..-1].sum == 0
			right = left
			while right < bw.size && right-left < CHARMAP.size-1 && delta[right] == flip
				right += 1
			end
			ret << enc(right-left)
			flip ^= 1
			left = right
		end
	end
	print %Q{"#{ret}",}
	@prev = bw
end

def footer(frameskip, res, differential_encoding)
	sqsize = 128/res
	<<EOF
}

n=#f*#{frameskip}
m={}

for i=1,#{CHARMAP.size} do
	m[sub("#{CHARMAP}",i,_)] = i-1
end

function _draw()
	n+=1
	if (n%#{frameskip}!=0) then return end

	if (n>#f*#{frameskip}) then
		cls()
		music()
		n=#{frameskip}
	end
	#{differential_encoding ? "c=true" : "c=0"}
	g=n/#{frameskip}
	p=4*m[sub(f[g],1,_)]
	for i=2,#f[g] do
		k=m[sub(f[g],i,_)]
		for j=1,k do
			x=(p%#{res})*#{sqsize}
			y=flr(p/#{res})*#{sqsize}
			#{differential_encoding ? "if (c) then
				c=bxor(7,pget(x,y))
				rectfill(x,y,x+#{sqsize-1},y+#{sqsize-1},c)
			end" : "rectfill(x,y,x+#{sqsize-1},y+#{sqsize-1},c)"}
			p+=1
		end
		#{differential_encoding ? "c=not c" : "c=(c+7)%14"}
	end
end
EOF
# c = color, or change flag
# f = frame data
# i, j = iterators
# k = run-length encoding count
# m = map from character value to 6-bit number
# n = counter from 1..number of _draw() calls (30*duration)
# g = counter from 1..number of frames (n/frameskip)
end

main
